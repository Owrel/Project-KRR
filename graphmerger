import clingo
import os
import time
import json

#TODO:
# compute difference metrics
# compute maxtime constant base



class GraphMerger:
    def __init__(self,
                 spf='pathfinding/path.lp',
                 mergers=[
                     'mergers/EdgeApproach/Diamond.lp',
                     'mergers/EdgeApproach/WaitOnly.lp',
                     'mergers/NodeApproach/Corridor.lp',
                     'mergers/NodeApproach/Diamond.lp',
                     'mergers/NodeApproach/DiamondCorridor.lp',
                     'mergers/NodeApproach/WaitOnly.lp'
                 ],
                 reseting=False
                 ):
        self.spf = spf
        self.mergers = mergers
        self.reseting = False


    def get_merger_name(self, merger):
        #prefix
        if 'NodeApproach' in merger :
            prefix = 'NodeApproach'
        elif 'EdgeApproach' in merger:
            prefix = 'EdgeApproach'
        else :
            prefix = ''

        #suffix
        if '/' in merger and '.lp' in merger:
            suffix = merger[merger.rindex('/')+1:merger.rindex('.lp')]
        elif '.lp' in merger:
            suffix = merger[:merger.rindex('.lp')]

        if prefix:
            return f'{prefix}{suffix}'
        else :
            return f'{suffix}'

    def compute_initial_path(self, instance):
        ctl = clingo.Control()
        ctl.load(instance)
        ctl.ground([("base", [])])
        result = []
        ctl.solve(on_model=lambda m: result.append((("{}".format(m)))))
        result = result[0].split(' ')
        robot = []
        for symbol in result:
            if 'init(object(robot,' in symbol:
                r = symbol[symbol.index(',')+1:symbol.index(')')]
                if not eval(r) in robot:
                    robot.append(eval(r))
        robot.sort()
        print(f'Number of single path to compute : {len(robot)}')
        ret = []
        for r in robot:
            start = time.time()
            ctl = clingo.Control('')
            ctl.load(instance)
            ctl.load(self.spf)
            ctl.add('base', [], f'pathfor({r}).')
            ctl.ground([("base", [])])
            ctl.solve()
            result = []
            ctl.solve(on_model=lambda m: result.append((("{}".format(m)))))
            if result:
                ret.append(result[-1].split(' '))


                print(f'Robot : {r} \t... Done in {time.time() - start}')
            else:
                print(f'Robot : {r} \t... Fail in {time.time() - start}')
                return []
        return ret

    def __call__(self, instance, output_directory='./benchmarks/'):
        global_ret = {}
        print(f'Working on instance : {instance}')
        if '/' in instance:
            folder = instance[:instance.rindex('/')+1]
        else:
            folder = './'

        if os.path.isfile(instance+".path") and not self.reseting:
            print('Reading from old computed path.')
            f = open(instance+".path", "r")
            path = f.read()
            pathfinding_time = "Imported"
        else:
            path = ''
            ret = self.compute_initial_path(instance)
            if ret:
                for r in ret:
                    r.sort()
                    for s in r:
                        path += s + '.\n'
                    path += '\n'

                f = open(instance+".path", "w")
                f.write(path)
                f.close()
            else:
                print('PATHFINDING UNSATISFIABLE')

        print('Merging')
        for merger in self.mergers:

            # Building result object
            ret = {
                'model': None,
                'sat': None,
                'merger': self.get_merger_name(merger),
                'problemtype' : 'targetassignement',
                'instance' : self.get_merger_name(instance) + '.lp'
            }

            print(f'Merger : {merger}')
            f = open(merger, "r")
            merger_program = f.read()

            ctl = clingo.Control(['-c maxtime=60'])
            ctl.load(merger)
            ctl.load(instance + '.path')

            start = time.time()
            ctl.ground([("base", [])])
            grounding_time = time.time()-start

            result = []
            ctl.solve(on_model=lambda m: result.append((("{}".format(m)))))

            total_time = ctl.statistics['summary']['times']['total']
            nb_atoms = ctl.statistics['problem']['lp']['atoms']
            nb_rules = ctl.statistics['problem']['lp']['rules']
         

            ret['rules'] = nb_rules
            ret['atoms'] = nb_atoms
            ret['grounding_time'] = grounding_time
            ret['cpu_time'] = ctl.statistics['summary']['times']['cpu']
            ret['total_time'] = total_time

            print('####### Result #######')
            print(f'\tSolved in {str(total_time)} sec.')
            print(f'\tAtoms : {str(nb_atoms)}')
            print(f'\tRules : {str(nb_rules)}')

            print(ret)
            if result:
                # print(result[-1])
                ret['model'] = result[-1].replace(' ', '. ')
                out = result[-1].replace(' ', '. ')
                out += '.'
                f = open("instances/lastout.lp", "w")
                f.write(out)
                f.close()
                print('+ SATISFIABLE')
                ret['sat'] = True
            else:
                print('- UNSATISFIABLE')
                ret['sat'] = False
            print()


            ## dumpings data
            f = open(f'{output_directory}{self.get_merger_name(instance)}{self.get_merger_name(merger)}.json', "w")
            f.write(json.dumps(ret,indent=2))
            f.close()
            




gm = GraphMerger()
gm('common_instances/26_diagonal_chaos.lp')

# graphmerger('instances/instance01.lp')
